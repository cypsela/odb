import * as cbor from '@ipld/dag-cbor'
import { base32 } from 'multiformats/bases/base32'
import type { Account, AccountData } from '@welo/account'

/**
 * Available roles/permissions for the operation log
 *
 * - reader: read permission but no write permission
 * - writer: read and write permissions
 * - mod: r/w permission, can also edit reader and writer list
 * - admin: r/w permission, can also edit reader, writer, and mod list
 */
export type Role = 'reader' | 'writer' | 'mod' | 'admin'

/**
 * The account access level and capability for the epoch
 * Also includes everything necessary to rebuild the Account so it can be verified
 */
export interface AccountAccess {
  sig: Account['sig']

  version: AccountData['version']

  name?: AccountData['name']

  role: Role

  /**
   * A mapping of AccountData[signers] to either null (WriteProtected) or an encrypted AES key (ReadProtected).
   * The AES key is generated by the epoch author and encrypted to each participant with a shared secret.
   */
  keys: Record<string, null> | Record<string, Uint8Array>
}

export interface WriteProtectedAccountAccess extends AccountAccess {
  /**
   * Maps signers of the account to nothing
   */
  keys: Record<string, null>
}

export interface ReadProtectedAccountAccess extends AccountAccess {
  /**
   * Maps signers of the account to a shared secret (author + signer) encrypted AES key
   */
  keys: Record<string, Uint8Array>
}

/**
 * Maps account ids to Account Access
 */
export interface EpochAccess {
  author?: Uint8Array
  accounts: Record<string, AccountAccess>
}

export interface WriteProtectedEpochAccess extends Omit<EpochAccess, 'author'> {
  accounts: Record<string, WriteProtectedAccountAccess>
}

export interface ReadProtectedEpochAccess extends Required<EpochAccess> {
  /**
   * An ephemeral Ed25519 public key used to derive shared secrets for each signer
   */
  author: Uint8Array
  accounts: Record<string, ReadProtectedAccountAccess>
}

/**
 * Maps epoch ids to EpochAccess
 */
export type Access = Record<string, EpochAccess>
export type WriteProtectedAccess = Record<string, WriteProtectedEpochAccess>
export type ReadProtectedAccess = Record<string, ReadProtectedEpochAccess>

/**
 * Rebuilds an Account from the account's id (base32 encoded Account[root]) and AccountAccess instance
 *
 * @param accountId - A base32 encoded Account[root]
 * @param accountAccess - An instance of AccountAccess matching the accountId
 * @returns
 */
export function rebuildAccount (accountId: string, accountAccess: AccountAccess): Account {
  const accountData: AccountData = {
    version: accountAccess.version,
    signers: Object.keys(accountAccess.keys).map(base32.decode)
  }

  if (accountAccess.name !== null) accountData.name = accountAccess.name

  return {
    root: base32.decode(accountId),
    data: cbor.encode(accountData),
    sig: accountAccess.sig
  }
}
